/*
Tendermint RPC

Tendermint supports the following RPC protocols:  * URI over HTTP * JSONRPC over HTTP * JSONRPC over websockets  ## Configuration  RPC can be configured by tuning parameters under `[rpc]` table in the `$TMHOME/config/config.toml` file or by using the `--rpc.X` command-line flags.  Default rpc listen address is `tcp://0.0.0.0:26657`. To set another address, set the `laddr` config parameter to desired value. CORS (Cross-Origin Resource Sharing) can be enabled by setting `cors_allowed_origins`, `cors_allowed_methods`, `cors_allowed_headers` config parameters.  ## Arguments  Arguments which expect strings or byte arrays may be passed as quoted strings, like `\"abc\"` or as `0x`-prefixed strings, like `0x616263`.  ## URI/HTTP  A REST like interface.      curl localhost:26657/block?height=5  ## JSONRPC/HTTP  JSONRPC requests can be POST'd to the root RPC endpoint via HTTP.      curl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' localhost:26657  ## JSONRPC/websockets  JSONRPC requests can be also made via websocket. The websocket endpoint is at `/websocket`, e.g. `localhost:26657/websocket`. Asynchronous RPC functions like event `subscribe` and `unsubscribe` are only available via websockets.  Example using https://github.com/hashrocket/ws:      ws ws://localhost:26657/websocket     > { \"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": [\"tm.event='NewBlock'\"], \"id\": 1 } 

API version: Master
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// WebsocketApiService WebsocketApi service
type WebsocketApiService service

type ApiSubscribeRequest struct {
	ctx context.Context
	ApiService *WebsocketApiService
	query *string
}

// query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time. 
func (r ApiSubscribeRequest) Query(query string) ApiSubscribeRequest {
	r.query = &query
	return r
}

func (r ApiSubscribeRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.SubscribeExecute(r)
}

/*
Subscribe Subscribe for events via WebSocket.

To tell which events you want, you need to provide a query. query is a
string, which has a form: "condition AND condition ..." (no OR at the
moment). condition has a form: "key operation operand". key is a string with
a restricted set of possible symbols ( \t\n\r\\()"'=>< are not allowed).
operation can be "=", "<", "<=", ">", ">=", "CONTAINS" AND "EXISTS". operand
can be a string (escaped with single quotes), number, date or time.

Examples:
      tm.event = 'NewBlock'               # new blocks
      tm.event = 'CompleteProposal'       # node got a complete proposal
      tm.event = 'Tx' AND tx.hash = 'XYZ' # single transaction
      tm.event = 'Tx' AND tx.height = 5   # all txs of the fifth block
      tx.height = 5                       # all txs of the fifth block

Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height.
Note for transactions, you can define additional keys by providing events with
DeliverTx response.

import (
    abci "github.com/tendermint/tendermint/abci/types"
    "github.com/tendermint/tendermint/libs/pubsub/query"
)

abci.ResponseDeliverTx{
  Events: []abci.Event{
      {
          Type: "rewards.withdraw",
          Attributes: []abci.EventAttribute{
              {Key: "address", Value: "AddrA", Index: true},
              {Key: "source", Value: "SrcX", Index: true},
              {Key: "amount", Value: "...", Index: true},
              {Key: "balance", Value: "...", Index: true},
          },
      },
      {
          Type: "rewards.withdraw",
          Attributes: []abci.EventAttribute{
              {Key: "address", Value: "AddrB", Index: true},
              {Key: "source", Value: "SrcY", Index: true},
              {Key: "amount", Value: "...", Index: true},
              {Key: "balance", Value: "...", Index: true},
          },
      },
      {
          Type: "transfer",
          Attributes: []abci.EventAttribute{
              {Key: "sender", Value: "AddrC", Index: true},
              {Key: "recipient", Value: "AddrD", Index: true},
              {Key: "amount", Value: "...", Index: true},
          },
      },
  },
}

All events are indexed by a composite key of the form {eventType}.{evenAttrKey}.
In the above examples, the following keys would be indexed:
   - rewards.withdraw.address
   - rewards.withdraw.source
   - rewards.withdraw.amount
   - rewards.withdraw.balance
   - transfer.sender
   - transfer.recipient
   - transfer.amount

Multiple event types with duplicate keys are allowed and are meant to
categorize unique and distinct events. In the above example, all events
indexed under the key `rewards.withdraw.address` will have the following
values stored and queryable:

   - AddrA
   - AddrB

To create a query for txs where address AddrA withdrew rewards:
query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA'")

To create a query for txs where address AddrA withdrew rewards from source Y:
query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA' AND rewards.withdraw.source = 'Y'")

To create a query for txs where AddrA transferred funds:
query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrA'")

The following queries would return no results:
query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrZ'")
query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrZ'")
query.MustParse("tm.event = 'Tx' AND rewards.withdraw.source = 'W'")

See list of all possible events here
https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants

For complete query syntax, check out
https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.

```go
import rpchttp "github.com/tendermint/rpc/client/http"
import "github.com/tendermint/tendermint/types"

client, err := rpchttp.New("tcp://0.0.0.0:26657", "/websocket")
if err != nil {
  // handle error
}

err = client.Start()
if err != nil {
  // handle error
}
defer client.Stop()
ctx, cancel := context.WithTimeout(context.Background(), 1 * time.Second)
defer cancel()
query := "tm.event = 'Tx' AND tx.height = 3"
txs, err := client.Subscribe(ctx, "test-client", query)
if err != nil {
  // handle error
}

go func() {
 for e := range txs {
   fmt.Println("got ", e.Data.(types.EventDataTx))
   }
}()
```

NOTE: if you're not reading events fast enough, Tendermint might
terminate the subscription.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubscribeRequest
*/
func (a *WebsocketApiService) Subscribe(ctx context.Context) ApiSubscribeRequest {
	return ApiSubscribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *WebsocketApiService) SubscribeExecute(r ApiSubscribeRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebsocketApiService.Subscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsubscribeRequest struct {
	ctx context.Context
	ApiService *WebsocketApiService
	query *string
}

// query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time. 
func (r ApiUnsubscribeRequest) Query(query string) ApiUnsubscribeRequest {
	r.query = &query
	return r
}

func (r ApiUnsubscribeRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.UnsubscribeExecute(r)
}

/*
Unsubscribe Unsubscribe from event on Websocket

```go
client, err := rpchttp.New("tcp://0.0.0.0:26657", "/websocket")
if err != nil {
  // handle error
}

err := client.Start()
if err != nil {
  // handle error
}
defer client.Stop()
query := "tm.event = 'Tx' AND tx.height = 3"
err = client.Unsubscribe(context.Background(), "test-client", query)
if err != nil {
  // handle error
}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnsubscribeRequest
*/
func (a *WebsocketApiService) Unsubscribe(ctx context.Context) ApiUnsubscribeRequest {
	return ApiUnsubscribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *WebsocketApiService) UnsubscribeExecute(r ApiUnsubscribeRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebsocketApiService.Unsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unsubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsubscribeAllRequest struct {
	ctx context.Context
	ApiService *WebsocketApiService
}

func (r ApiUnsubscribeAllRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.UnsubscribeAllExecute(r)
}

/*
UnsubscribeAll Unsubscribe from all events via WebSocket

Unsubscribe from all events via WebSocket


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnsubscribeAllRequest
*/
func (a *WebsocketApiService) UnsubscribeAll(ctx context.Context) ApiUnsubscribeAllRequest {
	return ApiUnsubscribeAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *WebsocketApiService) UnsubscribeAllExecute(r ApiUnsubscribeAllRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebsocketApiService.UnsubscribeAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unsubscribe_all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
