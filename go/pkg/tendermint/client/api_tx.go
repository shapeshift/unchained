/*
Tendermint RPC

Tendermint supports the following RPC protocols:  * URI over HTTP * JSONRPC over HTTP * JSONRPC over websockets  ## Configuration  RPC can be configured by tuning parameters under `[rpc]` table in the `$TMHOME/config/config.toml` file or by using the `--rpc.X` command-line flags.  Default rpc listen address is `tcp://0.0.0.0:26657`. To set another address, set the `laddr` config parameter to desired value. CORS (Cross-Origin Resource Sharing) can be enabled by setting `cors_allowed_origins`, `cors_allowed_methods`, `cors_allowed_headers` config parameters.  ## Arguments  Arguments which expect strings or byte arrays may be passed as quoted strings, like `\"abc\"` or as `0x`-prefixed strings, like `0x616263`.  ## URI/HTTP  A REST like interface.      curl localhost:26657/block?height=5  ## JSONRPC/HTTP  JSONRPC requests can be POST'd to the root RPC endpoint via HTTP.      curl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' localhost:26657  ## JSONRPC/websockets  JSONRPC requests can be also made via websocket. The websocket endpoint is at `/websocket`, e.g. `localhost:26657/websocket`. Asynchronous RPC functions like event `subscribe` and `unsubscribe` are only available via websockets.  Example using https://github.com/hashrocket/ws:      ws ws://localhost:26657/websocket     > { \"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": [\"tm.event='NewBlock'\"], \"id\": 1 } 

API version: Master
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// TxApiService TxApi service
type TxApiService service

type ApiBroadcastTxAsyncRequest struct {
	ctx context.Context
	ApiService *TxApiService
	tx *string
}

// The transaction
func (r ApiBroadcastTxAsyncRequest) Tx(tx string) ApiBroadcastTxAsyncRequest {
	r.tx = &tx
	return r
}

func (r ApiBroadcastTxAsyncRequest) Execute() (*BroadcastTxResponse, *http.Response, error) {
	return r.ApiService.BroadcastTxAsyncExecute(r)
}

/*
BroadcastTxAsync Returns right away, with no response. Does not wait for CheckTx nor DeliverTx results.

If you want to be sure that the transaction is included in a block, you can
subscribe for the result using JSONRPC via a websocket. See
https://docs.tendermint.com/master/app-dev/subscribing-to-events-via-websocket.html
If you haven't received anything after a couple of blocks, resend it. If the
same happens again, send it to some other node. A few reasons why it could
happen:

1. malicious node can drop or pretend it had committed your tx
2. malicious proposer (not necessary the one you're communicating with) can
drop transactions, which might become valid in the future
(https://github.com/tendermint/tendermint/issues/3322)
3. node can be offline

Please refer to
https://docs.tendermint.com/master/tendermint-core/using-tendermint.html#formatting
for formatting/encoding rules.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBroadcastTxAsyncRequest
*/
func (a *TxApiService) BroadcastTxAsync(ctx context.Context) ApiBroadcastTxAsyncRequest {
	return ApiBroadcastTxAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BroadcastTxResponse
func (a *TxApiService) BroadcastTxAsyncExecute(r ApiBroadcastTxAsyncRequest) (*BroadcastTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BroadcastTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TxApiService.BroadcastTxAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast_tx_async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tx == nil {
		return localVarReturnValue, nil, reportError("tx is required and must be specified")
	}

	localVarQueryParams.Add("tx", parameterToString(*r.tx, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastTxCommitRequest struct {
	ctx context.Context
	ApiService *TxApiService
	tx *string
}

// The transaction
func (r ApiBroadcastTxCommitRequest) Tx(tx string) ApiBroadcastTxCommitRequest {
	r.tx = &tx
	return r
}

func (r ApiBroadcastTxCommitRequest) Execute() (*BroadcastTxCommitResponse, *http.Response, error) {
	return r.ApiService.BroadcastTxCommitExecute(r)
}

/*
BroadcastTxCommit Returns with the responses from CheckTx and DeliverTx.

IMPORTANT: use only for testing and development. In production, use
BroadcastTxSync or BroadcastTxAsync. You can subscribe for the transaction
result using JSONRPC via a websocket. See
https://docs.tendermint.com/master/app-dev/subscribing-to-events-via-websocket.html

CONTRACT: only returns error if mempool.CheckTx() errs or if we timeout
waiting for tx to commit.

If CheckTx or DeliverTx fail, no error will be returned, but the returned result
will contain a non-OK ABCI code.

Please refer to
https://docs.tendermint.com/master/tendermint-core/using-tendermint.html#formatting
for formatting/encoding rules.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBroadcastTxCommitRequest
*/
func (a *TxApiService) BroadcastTxCommit(ctx context.Context) ApiBroadcastTxCommitRequest {
	return ApiBroadcastTxCommitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BroadcastTxCommitResponse
func (a *TxApiService) BroadcastTxCommitExecute(r ApiBroadcastTxCommitRequest) (*BroadcastTxCommitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BroadcastTxCommitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TxApiService.BroadcastTxCommit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast_tx_commit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tx == nil {
		return localVarReturnValue, nil, reportError("tx is required and must be specified")
	}

	localVarQueryParams.Add("tx", parameterToString(*r.tx, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastTxSyncRequest struct {
	ctx context.Context
	ApiService *TxApiService
	tx *string
}

// The transaction
func (r ApiBroadcastTxSyncRequest) Tx(tx string) ApiBroadcastTxSyncRequest {
	r.tx = &tx
	return r
}

func (r ApiBroadcastTxSyncRequest) Execute() (*BroadcastTxResponse, *http.Response, error) {
	return r.ApiService.BroadcastTxSyncExecute(r)
}

/*
BroadcastTxSync Returns with the response from CheckTx. Does not wait for DeliverTx result.

If you want to be sure that the transaction is included in a block, you can
subscribe for the result using JSONRPC via a websocket. See
https://docs.tendermint.com/master/app-dev/subscribing-to-events-via-websocket.html
If you haven't received anything after a couple of blocks, resend it. If the
same happens again, send it to some other node. A few reasons why it could
happen:

1. malicious node can drop or pretend it had committed your tx
2. malicious proposer (not necessary the one you're communicating with) can
drop transactions, which might become valid in the future
(https://github.com/tendermint/tendermint/issues/3322)


Please refer to
https://docs.tendermint.com/master/tendermint-core/using-tendermint.html#formatting
for formatting/encoding rules.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBroadcastTxSyncRequest
*/
func (a *TxApiService) BroadcastTxSync(ctx context.Context) ApiBroadcastTxSyncRequest {
	return ApiBroadcastTxSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BroadcastTxResponse
func (a *TxApiService) BroadcastTxSyncExecute(r ApiBroadcastTxSyncRequest) (*BroadcastTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BroadcastTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TxApiService.BroadcastTxSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast_tx_sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tx == nil {
		return localVarReturnValue, nil, reportError("tx is required and must be specified")
	}

	localVarQueryParams.Add("tx", parameterToString(*r.tx, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckTxRequest struct {
	ctx context.Context
	ApiService *TxApiService
	tx *string
}

// The transaction
func (r ApiCheckTxRequest) Tx(tx string) ApiCheckTxRequest {
	r.tx = &tx
	return r
}

func (r ApiCheckTxRequest) Execute() (*CheckTxResponse, *http.Response, error) {
	return r.ApiService.CheckTxExecute(r)
}

/*
CheckTx Checks the transaction without executing it.

The transaction won't be added to the mempool.

Please refer to
https://docs.tendermint.com/master/tendermint-core/using-tendermint.html#formatting
for formatting/encoding rules.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckTxRequest
*/
func (a *TxApiService) CheckTx(ctx context.Context) ApiCheckTxRequest {
	return ApiCheckTxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckTxResponse
func (a *TxApiService) CheckTxExecute(r ApiCheckTxRequest) (*CheckTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TxApiService.CheckTx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/check_tx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tx == nil {
		return localVarReturnValue, nil, reportError("tx is required and must be specified")
	}

	localVarQueryParams.Add("tx", parameterToString(*r.tx, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
