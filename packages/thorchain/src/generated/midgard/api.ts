/* tslint:disable */
/* eslint-disable */
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.4.1
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * action details among with related transactions
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * Pools involved in the action
     * @type {Array<string>}
     * @memberof Action
     */
    pools: Array<string>;
    /**
     * Type of action
     * @type {string}
     * @memberof Action
     */
    type: ActionTypeEnum;
    /**
     * Indicates if the action is completed or if related outbound transactions are still pending.
     * @type {string}
     * @memberof Action
     */
    status: ActionStatusEnum;
    /**
     * Inbound transactions related to the action
     * @type {Array<Transaction>}
     * @memberof Action
     */
    in: Array<Transaction>;
    /**
     * Outbound transactions related to the action
     * @type {Array<Transaction>}
     * @memberof Action
     */
    out: Array<Transaction>;
    /**
     * Int64, nano timestamp of the block at which the action was registered
     * @type {string}
     * @memberof Action
     */
    date: string;
    /**
     * Int64, height of the block at which the action was registered
     * @type {string}
     * @memberof Action
     */
    height: string;
    /**
     * 
     * @type {Metadata}
     * @memberof Action
     */
    metadata: Metadata;
}

/**
    * @export
    * @enum {string}
    */
export enum ActionTypeEnum {
    Swap = 'swap',
    AddLiquidity = 'addLiquidity',
    Withdraw = 'withdraw',
    Donate = 'donate',
    Refund = 'refund',
    Switch = 'switch'
}
/**
    * @export
    * @enum {string}
    */
export enum ActionStatusEnum {
    Success = 'success',
    Pending = 'pending'
}

/**
 * 
 * @export
 * @interface AddLiquidityMetadata
 */
export interface AddLiquidityMetadata {
    /**
     * Int64, amount of liquidity units assigned to the member as result of the liquidity deposit
     * @type {string}
     * @memberof AddLiquidityMetadata
     */
    liquidityUnits: string;
}
/**
 * 
 * @export
 * @interface BlockRewards
 */
export interface BlockRewards {
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    blockReward: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    bondReward: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    poolReward: string;
}
/**
 * 
 * @export
 * @interface BondMetrics
 */
export interface BondMetrics {
    /**
     * Int64(e8), Total bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalActiveBond: string;
    /**
     * Int64(e8), Average bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageActiveBond: string;
    /**
     * Int64(e8), Median bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianActiveBond: string;
    /**
     * Int64(e8), Minumum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumActiveBond: string;
    /**
     * Int64(e8), Maxinum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumActiveBond: string;
    /**
     * Int64(e8), Total bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalStandbyBond: string;
    /**
     * Int64(e8), Average bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageStandbyBond: string;
    /**
     * Int64(e8), Median bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianStandbyBond: string;
    /**
     * Int64(e8), Minumum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumStandbyBond: string;
    /**
     * Int64(e8), Maximum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumStandbyBond: string;
}
/**
 * 
 * @export
 * @interface BoolConstants
 */
export interface BoolConstants {
    /**
     * 
     * @type {boolean}
     * @memberof BoolConstants
     */
    StrictBondLiquidityRatio: boolean;
}
/**
 * Represents a digital currency amount
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * Asset in CHAIN.SYMBOL format
     * @type {string}
     * @memberof Coin
     */
    asset: string;
    /**
     * Int64(e8), asset Amount.
     * @type {string}
     * @memberof Coin
     */
    amount: string;
}
/**
 * 
 * @export
 * @interface Constants
 */
export interface Constants {
    /**
     * 
     * @type {Int64Constants}
     * @memberof Constants
     */
    int_64_values: Int64Constants;
    /**
     * 
     * @type {BoolConstants}
     * @memberof Constants
     */
    bool_values: BoolConstants;
    /**
     * 
     * @type {StringConstants}
     * @memberof Constants
     */
    string_values: StringConstants;
}
/**
 * 
 * @export
 * @interface DepthHistory
 */
export interface DepthHistory {
    /**
     * 
     * @type {DepthHistoryMeta}
     * @memberof DepthHistory
     */
    meta: DepthHistoryMeta;
    /**
     * 
     * @type {Array<DepthHistoryItem>}
     * @memberof DepthHistory
     */
    intervals: Array<DepthHistoryItem>;
}
/**
 * 
 * @export
 * @interface DepthHistoryItem
 */
export interface DepthHistoryItem {
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryItem
     */
    startTime: string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryItem
     */
    endTime: string;
    /**
     * Int64(e8), the amount of Asset in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    assetDepth: string;
    /**
     * Int64(e8), the amount of Rune in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    runeDepth: string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount
     * @type {string}
     * @memberof DepthHistoryItem
     */
    assetPrice: string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof DepthHistoryItem
     */
    assetPriceUSD: string;
    /**
     * Int64, Liquidity Units in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    liquidityUnits: string;
    /**
     * Int64, Synth Units in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    synthUnits: string;
    /**
     * Int64, Synth supply in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    synthSupply: string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    units: string;
}
/**
 * 
 * @export
 * @interface DepthHistoryMeta
 */
export interface DepthHistoryMeta {
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    startTime: string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    endTime: string;
}
/**
 * 
 * @export
 * @interface EarningsHistory
 */
export interface EarningsHistory {
    /**
     * 
     * @type {EarningsHistoryItem}
     * @memberof EarningsHistory
     */
    meta: EarningsHistoryItem;
    /**
     * 
     * @type {Array<EarningsHistoryItem>}
     * @memberof EarningsHistory
     */
    intervals: Array<EarningsHistoryItem>;
}
/**
 * 
 * @export
 * @interface EarningsHistoryItem
 */
export interface EarningsHistoryItem {
    /**
     * Int64, The beginning time of interval in unix timestamp
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    startTime: string;
    /**
     * Int64, The end time of interval in unix timestamp
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    endTime: string;
    /**
     * Int64(e8), Total liquidity fees, converted to RUNE, collected during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    liquidityFees: string;
    /**
     * Int64(e8), Total block rewards emitted during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    blockRewards: string;
    /**
     * Int64(e8), System income generated during the time interval. It is the sum of liquidity fees and block rewards
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    earnings: string;
    /**
     * Int64(e8), Share of earnings sent to nodes during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    bondingEarnings: string;
    /**
     * Int64(e8), Share of earnings sent to pools during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    liquidityEarnings: string;
    /**
     * float64, Average amount of active nodes during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    avgNodeCount: string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    runePriceUSD: string;
    /**
     * Earnings data for each pool for the time interval
     * @type {Array<EarningsHistoryItemPool>}
     * @memberof EarningsHistoryItem
     */
    pools: Array<EarningsHistoryItemPool>;
}
/**
 * pool earnings data during the time interval
 * @export
 * @interface EarningsHistoryItemPool
 */
export interface EarningsHistoryItemPool {
    /**
     * asset for the given pool
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    pool: string;
    /**
     * Int64(e8), liquidity fees collected in the pool\'s asset
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    assetLiquidityFees: string;
    /**
     * Int64(e8), liquidity fees collected in RUNE
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    runeLiquidityFees: string;
    /**
     * Int64(e8), total liquidity fees (assetFees + runeFees) collected, shown in RUNE
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    totalLiquidityFeesRune: string;
    /**
     * Int64(e8), RUNE amount sent to (positive) or taken from (negative) the pool as a result of balancing it\'s share of system income each block 
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    rewards: string;
    /**
     * Int64(e8), total earnings in RUNE (totalLiquidityFees + rewards)
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    earnings: string;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * True means healthy, connected to database
     * @type {boolean}
     * @memberof Health
     */
    database: boolean;
    /**
     * Int64, the current block count
     * @type {string}
     * @memberof Health
     */
    scannerHeight: string;
    /**
     * True means healthy. False means Midgard is still catching up to the chain
     * @type {boolean}
     * @memberof Health
     */
    inSync: boolean;
}
/**
 * 
 * @export
 * @interface InboundAddressesItem
 */
export interface InboundAddressesItem {
    /**
     * 
     * @type {string}
     * @memberof InboundAddressesItem
     */
    chain: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddressesItem
     */
    pub_key: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddressesItem
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddressesItem
     */
    router?: string;
    /**
     * indicate whether this chain has halted
     * @type {boolean}
     * @memberof InboundAddressesItem
     */
    halted: boolean;
    /**
     * 
     * @type {string}
     * @memberof InboundAddressesItem
     */
    gas_rate?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Int64, number of results matching the given filters.
     * @type {string}
     * @memberof InlineResponse200
     */
    count: string;
    /**
     * 
     * @type {Array<Action>}
     * @memberof InlineResponse200
     */
    actions: Array<Action>;
}
/**
 * 
 * @export
 * @interface Int64Constants
 */
export interface Int64Constants {
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    AsgardSize: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    BadValidatorRate: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    BadValidatorRedline: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    BlocksPerYear: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    ChurnInterval: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    ChurnRetryInterval: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    DesiredValidatorSet: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    DoubleSignMaxAge: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    EmissionCurve: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    FailKeygenSlashPoints: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    FailKeysignSlashPoints: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    FullImpLossProtectionBlocks: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    FundMigrationInterval: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    IncentiveCurve: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    JailTimeKeygen: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    JailTimeKeysign: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    LackOfObservationPenalty: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    LiquidityLockUpBlocks: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MaxAvailablePools: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MaxSwapsPerBlock: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinRunePoolDepth: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinSlashPointsForBadValidator: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinSwapsPerBlock: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinimumBondInRune: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinimumNodesForBFT: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    MinimumNodesForYggdrasil: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    NativeTransactionFee: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    NewPoolCycle?: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    ObservationDelayFlexibility: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    ObserveSlashPoints: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    OldValidatorRate: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    OutboundTransactionFee: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    PoolCycle: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    SigningTransactionPeriod: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    VirtualMultSynths: number;
    /**
     * 
     * @type {number}
     * @memberof Int64Constants
     */
    YggFundLimit: number;
}
/**
 * 
 * @export
 * @interface LastblockItem
 */
export interface LastblockItem {
    /**
     * 
     * @type {string}
     * @memberof LastblockItem
     */
    chain: string;
    /**
     * 
     * @type {number}
     * @memberof LastblockItem
     */
    last_observed_in: number;
    /**
     * 
     * @type {number}
     * @memberof LastblockItem
     */
    last_signed_out: number;
    /**
     * 
     * @type {number}
     * @memberof LastblockItem
     */
    thorchain: number;
}
/**
 * 
 * @export
 * @interface LiquidityHistory
 */
export interface LiquidityHistory {
    /**
     * 
     * @type {LiquidityHistoryItem}
     * @memberof LiquidityHistory
     */
    meta: LiquidityHistoryItem;
    /**
     * 
     * @type {Array<LiquidityHistoryItem>}
     * @memberof LiquidityHistory
     */
    intervals: Array<LiquidityHistoryItem>;
}
/**
 * 
 * @export
 * @interface LiquidityHistoryItem
 */
export interface LiquidityHistoryItem {
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    startTime: string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    endTime: string;
    /**
     * Int64(e8), total assets deposited during the time interval. Denoted in Rune using the price at deposit time. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    addAssetLiquidityVolume: string;
    /**
     * Int64(e8), total Rune deposited during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    addRuneLiquidityVolume: string;
    /**
     * Int64(e8), total of rune and asset deposits. Denoted in Rune (using the price at deposit time). 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    addLiquidityVolume: string;
    /**
     * Int64, number of deposits during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    addLiquidityCount: string;
    /**
     * Int64(e8), total assets withdrawn during the time interval. Denoted in Rune using the price at withdraw time. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    withdrawAssetVolume: string;
    /**
     * Int64(e8), total Rune withdrawn during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    withdrawRuneVolume: string;
    /**
     * Int64(e8), part of the withdrawRuneVolume which was payed because of impermanent loss protection. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    impermanentLossProtectionPaid: string;
    /**
     * Int64(e8), total of rune and asset withdrawals. Denoted in Rune (using the price at withdraw time). 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    withdrawVolume: string;
    /**
     * Int64, number of withdraw during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    withdrawCount: string;
    /**
     * Int64(e8), net liquidity changes (withdrawals - deposits) during the time interval
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    net: string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    runePriceUSD: string;
}
/**
 * 
 * @export
 * @interface MemberDetails
 */
export interface MemberDetails {
    /**
     * List details of all the liquidity providers identified with the given address
     * @type {Array<MemberPool>}
     * @memberof MemberDetails
     */
    pools: Array<MemberPool>;
}
/**
 * 
 * @export
 * @interface MemberPool
 */
export interface MemberPool {
    /**
     * Pool rest of the data refers to
     * @type {string}
     * @memberof MemberPool
     */
    pool: string;
    /**
     * Rune address used by the member
     * @type {string}
     * @memberof MemberPool
     */
    runeAddress: string;
    /**
     * asset address used by the member
     * @type {string}
     * @memberof MemberPool
     */
    assetAddress: string;
    /**
     * Int64, pool liquidity units that belong the the member
     * @type {string}
     * @memberof MemberPool
     */
    liquidityUnits: string;
    /**
     * Int64(e8), total Rune added to the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    runeAdded: string;
    /**
     * Int64(e8), total asset added to the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    assetAdded: string;
    /**
     * Int64(e8), Rune sent but not added yet, it will be added when the asset pair arrives 
     * @type {string}
     * @memberof MemberPool
     */
    runePending: string;
    /**
     * Int64(e8), asset sent but not added yet, it will be added when the rune pair arrives 
     * @type {string}
     * @memberof MemberPool
     */
    assetPending: string;
    /**
     * Int64(e8), total Rune withdrawn from the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    runeWithdrawn: string;
    /**
     * Int64(e8), total asset withdrawn from the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    assetWithdrawn: string;
    /**
     * Int64, Unix timestamp for the first time member deposited into the pool
     * @type {string}
     * @memberof MemberPool
     */
    dateFirstAdded: string;
    /**
     * Int64, Unix timestamp for the last time member deposited into the pool
     * @type {string}
     * @memberof MemberPool
     */
    dateLastAdded: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {SwapMetadata}
     * @memberof Metadata
     */
    swap?: SwapMetadata;
    /**
     * 
     * @type {AddLiquidityMetadata}
     * @memberof Metadata
     */
    addLiquidity?: AddLiquidityMetadata;
    /**
     * 
     * @type {WithdrawMetadata}
     * @memberof Metadata
     */
    withdraw?: WithdrawMetadata;
    /**
     * 
     * @type {RefundMetadata}
     * @memberof Metadata
     */
    refund?: RefundMetadata;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {BondMetrics}
     * @memberof Network
     */
    bondMetrics: BondMetrics;
    /**
     * 
     * @type {BlockRewards}
     * @memberof Network
     */
    blockRewards: BlockRewards;
    /**
     * 
     * @type {Array<string>}
     * @memberof Network
     */
    activeBonds: Array<string>;
    /**
     * Array of Standby Bonds
     * @type {Array<string>}
     * @memberof Network
     */
    standbyBonds: Array<string>;
    /**
     * Int64, Number of Active Nodes
     * @type {string}
     * @memberof Network
     */
    activeNodeCount: string;
    /**
     * Int64, Number of Standby Nodes
     * @type {string}
     * @memberof Network
     */
    standbyNodeCount: string;
    /**
     * Int64(e8), Total Rune pooled in all pools
     * @type {string}
     * @memberof Network
     */
    totalPooledRune: string;
    /**
     * Int64(e8), Total left in Reserve
     * @type {string}
     * @memberof Network
     */
    totalReserve: string;
    /**
     * Int64, next height of blocks
     * @type {string}
     * @memberof Network
     */
    nextChurnHeight: string;
    /**
     * Int64, the remaining time of pool activation (in blocks)
     * @type {string}
     * @memberof Network
     */
    poolActivationCountdown: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    poolShareFactor: string;
    /**
     * Float, (1 + (bondReward * blocksPerMonth/totalActiveBond)) ^ 12 -1
     * @type {string}
     * @memberof Network
     */
    bondingAPY: string;
    /**
     * Float, (1 + (stakeReward * blocksPerMonth/totalDepth of active pools)) ^ 12 -1
     * @type {string}
     * @memberof Network
     */
    liquidityAPY: string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * node thorchain address
     * @type {string}
     * @memberof Node
     */
    nodeAddress: string;
    /**
     * secp256k1 public key
     * @type {string}
     * @memberof Node
     */
    secp256k1: string;
    /**
     * ed25519 public key
     * @type {string}
     * @memberof Node
     */
    ed25519: string;
}
/**
 * 
 * @export
 * @interface ObservedChain
 */
export interface ObservedChain {
    /**
     * 
     * @type {string}
     * @memberof ObservedChain
     */
    chain: string;
    /**
     * 
     * @type {number}
     * @memberof ObservedChain
     */
    height: number;
}
/**
 * 
 * @export
 * @interface PoolDetail
 */
export interface PoolDetail {
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    asset: string;
    /**
     * Int64(e8), the total volume of swaps in the last 24h to and from Rune denoted in Rune.
     * @type {string}
     * @memberof PoolDetail
     */
    volume24h: string;
    /**
     * Int64(e8), the amount of Asset in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    assetDepth: string;
    /**
     * Int64(e8), the amount of Rune in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    runeDepth: string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount.
     * @type {string}
     * @memberof PoolDetail
     */
    assetPrice: string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof PoolDetail
     */
    assetPriceUSD: string;
    /**
     * Float, Average Percentage Yield: annual return estimated using last weeks income, taking compound interest into account.
     * @type {string}
     * @memberof PoolDetail
     */
    poolAPY: string;
    /**
     * The state of the pool, e.g. Available, Staged.
     * @type {string}
     * @memberof PoolDetail
     */
    status: string;
    /**
     * Int64, Liquidity Units in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    liquidityUnits: string;
    /**
     * Int64, Synth Units in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    synthUnits: string;
    /**
     * Int64, Synth supply in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    synthSupply: string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    units: string;
}
/**
 * 
 * @export
 * @interface PoolStatsDetail
 */
export interface PoolStatsDetail {
    /**
     * 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    asset: string;
    /**
     * The state of the pool, e.g. Available, Staged
     * @type {string}
     * @memberof PoolStatsDetail
     */
    status: string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    assetPrice: string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof PoolStatsDetail
     */
    assetPriceUSD: string;
    /**
     * Int64(e8), the amount of Asset in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    assetDepth: string;
    /**
     * Int64(e8), the amount of Rune in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    runeDepth: string;
    /**
     * Int64, Synth Units in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    synthUnits: string;
    /**
     * Int64, Synth supply in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    synthSupply: string;
    /**
     * Int64, Liquidity Units in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    liquidityUnits: string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    units: string;
    /**
     * Int64(e8), same as history/swaps:toAssetVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toAssetVolume: string;
    /**
     * Int64(e8), same as history/swaps:toRuneVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toRuneVolume: string;
    /**
     * Int64(e8), same as history/swaps:totalVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    swapVolume: string;
    /**
     * Int64, same as history/swaps:toAssetCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toAssetCount: string;
    /**
     * Int64, same as history/swaps:toRuneCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toRuneCount: string;
    /**
     * Int64, same as history/swaps:totalCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    swapCount: string;
    /**
     * Int64, number of unique adresses that initiated swaps transactions in the period. 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    uniqueSwapperCount: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:toAssetAverageSlip
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toAssetAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:toRuneAverageSlip
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toRuneAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:averageSlip
     * @type {string}
     * @memberof PoolStatsDetail
     */
    averageSlip: string;
    /**
     * Int64(e8), same as history/swaps:toAssetFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toAssetFees: string;
    /**
     * Int64(e8), same as history/swaps:toRuneFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    toRuneFees: string;
    /**
     * Int64(e8), same as history/swaps:totalFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    totalFees: string;
    /**
     * Float, Average Percentage Yield: annual return estimated using last weeks income, taking compound interest into account.
     * @type {string}
     * @memberof PoolStatsDetail
     */
    poolAPY: string;
    /**
     * Int64(e8), same as history/liquidity_changes:addAssetLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    addAssetLiquidityVolume: string;
    /**
     * Int64(e8), same as history/liquidity_changes:addRuneLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    addRuneLiquidityVolume: string;
    /**
     * Int64(e8), same as history/liquidity_changes:addLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    addLiquidityVolume: string;
    /**
     * Int64, same as history/liquidity_changes:addLiquidityCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    addLiquidityCount: string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawAssetVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    withdrawAssetVolume: string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawRuneVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    withdrawRuneVolume: string;
    /**
     * Int64(e8), part of the withdrawRuneVolume which was payed because of impermanent loss protection. 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    impermanentLossProtectionPaid: string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    withdrawVolume: string;
    /**
     * Int64, same as history/liquidity_changes:withdrawCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    withdrawCount: string;
    /**
     * Int64, same as len(history/members?pool=POOL)
     * @type {string}
     * @memberof PoolStatsDetail
     */
    uniqueMemberCount: string;
}
/**
 * 
 * @export
 * @interface PreflightStatus
 */
export interface PreflightStatus {
    /**
     * 
     * @type {string}
     * @memberof PreflightStatus
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof PreflightStatus
     */
    reason: string;
    /**
     * 
     * @type {number}
     * @memberof PreflightStatus
     */
    code: number;
}
/**
 * 
 * @export
 * @interface ProxiedNode
 */
export interface ProxiedNode {
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    node_address: string;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    status: string;
    /**
     * 
     * @type {ProxiedNodePubKeySet}
     * @memberof ProxiedNode
     */
    pub_key_set: ProxiedNodePubKeySet;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    validator_cons_pub_key: string;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    bond: string;
    /**
     * 
     * @type {number}
     * @memberof ProxiedNode
     */
    active_block_height: number;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    bond_address: string;
    /**
     * 
     * @type {number}
     * @memberof ProxiedNode
     */
    status_since: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProxiedNode
     */
    signer_membership: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ProxiedNode
     */
    requested_to_leave: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProxiedNode
     */
    forced_to_leave: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProxiedNode
     */
    leave_height: number;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    ip_address: string;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    version: string;
    /**
     * 
     * @type {number}
     * @memberof ProxiedNode
     */
    slash_points: number;
    /**
     * 
     * @type {ProxiedNodeJail}
     * @memberof ProxiedNode
     */
    jail: ProxiedNodeJail;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNode
     */
    current_award: string;
    /**
     * 
     * @type {Array<ObservedChain>}
     * @memberof ProxiedNode
     */
    observe_chains: Array<ObservedChain>;
    /**
     * 
     * @type {PreflightStatus}
     * @memberof ProxiedNode
     */
    preflight_status: PreflightStatus;
}
/**
 * 
 * @export
 * @interface ProxiedNodeJail
 */
export interface ProxiedNodeJail {
    /**
     * 
     * @type {string}
     * @memberof ProxiedNodeJail
     */
    node_address?: string;
}
/**
 * 
 * @export
 * @interface ProxiedNodePubKeySet
 */
export interface ProxiedNodePubKeySet {
    /**
     * 
     * @type {string}
     * @memberof ProxiedNodePubKeySet
     */
    secp256k1: string;
    /**
     * 
     * @type {string}
     * @memberof ProxiedNodePubKeySet
     */
    ed25519: string;
}
/**
 * 
 * @export
 * @interface Queue
 */
export interface Queue {
    /**
     * 
     * @type {number}
     * @memberof Queue
     */
    swap: number;
    /**
     * 
     * @type {number}
     * @memberof Queue
     */
    outbound: number;
    /**
     * 
     * @type {number}
     * @memberof Queue
     */
    internal: number;
}
/**
 * 
 * @export
 * @interface RefundMetadata
 */
export interface RefundMetadata {
    /**
     * List of network fees associated to an action. One network fee is charged for each outbound transaction
     * @type {Array<Coin>}
     * @memberof RefundMetadata
     */
    networkFees: Array<Coin>;
    /**
     * Reason for the refund
     * @type {string}
     * @memberof RefundMetadata
     */
    reason: string;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * Int64(e8), current total Rune in the pools.
     * @type {string}
     * @memberof StatsData
     */
    runeDepth: string;
    /**
     * Int64(e8), amount of native rune switched from erc20 or BEPSwap rune.
     * @type {string}
     * @memberof StatsData
     */
    switchedRune: string;
    /**
     * Float, the price of Rune based on the deepest USD pool.
     * @type {string}
     * @memberof StatsData
     */
    runePriceUSD: string;
    /**
     * Int64(e8), total volume of swaps denoted in Rune since beginning.
     * @type {string}
     * @memberof StatsData
     */
    swapVolume: string;
    /**
     * Int64(e8), number of swaps in the last 24h.
     * @type {string}
     * @memberof StatsData
     */
    swapCount24h: string;
    /**
     * Int64, number of swaps in the last 30d.
     * @type {string}
     * @memberof StatsData
     */
    swapCount30d: string;
    /**
     * Int64, number of swaps since beginning.
     * @type {string}
     * @memberof StatsData
     */
    swapCount: string;
    /**
     * Int64, number of swaps from Rune to Asset since beginning.
     * @type {string}
     * @memberof StatsData
     */
    toAssetCount: string;
    /**
     * Int64, number of swaps from Asset to Rune since beginning.
     * @type {string}
     * @memberof StatsData
     */
    toRuneCount: string;
    /**
     * Int64, unique users (addresses) initiating swaps in the last 24 hours.
     * @type {string}
     * @memberof StatsData
     */
    dailyActiveUsers: string;
    /**
     * Int64, unique users (addresses) initiating swaps in the last 30 days.
     * @type {string}
     * @memberof StatsData
     */
    monthlyActiveUsers: string;
    /**
     * Int64, unique users (addresses) initiating swaps since beginning.
     * @type {string}
     * @memberof StatsData
     */
    uniqueSwapperCount: string;
    /**
     * Int64(e8), total of deposits since beginning. 
     * @type {string}
     * @memberof StatsData
     */
    addLiquidityVolume: string;
    /**
     * Int64(e8), total of withdraws since beginning. 
     * @type {string}
     * @memberof StatsData
     */
    withdrawVolume: string;
    /**
     * Int64(e8), impermanent loss protection paid out. 
     * @type {string}
     * @memberof StatsData
     */
    impermanentLossProtectionPaid: string;
    /**
     * Int64, number of deposits since beginning.
     * @type {string}
     * @memberof StatsData
     */
    addLiquidityCount: string;
    /**
     * Int64, number of withdraws since beginning.
     * @type {string}
     * @memberof StatsData
     */
    withdrawCount: string;
}
/**
 * 
 * @export
 * @interface StringConstants
 */
export interface StringConstants {
    /**
     * 
     * @type {string}
     * @memberof StringConstants
     */
    DefaultPoolStatus: string;
}
/**
 * 
 * @export
 * @interface SwapHistory
 */
export interface SwapHistory {
    /**
     * 
     * @type {SwapHistoryItem}
     * @memberof SwapHistory
     */
    meta: SwapHistoryItem;
    /**
     * 
     * @type {Array<SwapHistoryItem>}
     * @memberof SwapHistory
     */
    intervals: Array<SwapHistoryItem>;
}
/**
 * 
 * @export
 * @interface SwapHistoryItem
 */
export interface SwapHistoryItem {
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof SwapHistoryItem
     */
    startTime: string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof SwapHistoryItem
     */
    endTime: string;
    /**
     * Int64, count of swaps from rune to asset
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toAssetCount: string;
    /**
     * Int64, count of swaps from asset to rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toRuneCount: string;
    /**
     * Int64, count of rune to synthetic asset swaps
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthMintCount: string;
    /**
     * Int64, count of synthetic asset to rune swaps
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthRedeemCount: string;
    /**
     * Int64, toAssetCount + toRuneCount + synthMintCount + synthRedeemCount
     * @type {string}
     * @memberof SwapHistoryItem
     */
    totalCount: string;
    /**
     * Int64(e8), volume of swaps from rune to asset denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toAssetVolume: string;
    /**
     * Int64(e8), volume of swaps from asset to rune denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toRuneVolume: string;
    /**
     * Int64(e8), volume of swaps from rune to synthetic asset denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthMintVolume: string;
    /**
     * Int64(e8), volume of swaps from synthetic asset to rune denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthRedeemVolume: string;
    /**
     * Int64(e8), toAssetVolume + toRuneVolume + synthMintVolume + synthRedeemVolume (denoted in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    totalVolume: string;
    /**
     * Int64(e8), the fees collected from swaps from rune to asset (in rune)
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toAssetFees: string;
    /**
     * Int64(e8), the fees collected from swaps from asset to rune (in rune)
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toRuneFees: string;
    /**
     * Int64(e8), the fees collected from swaps from rune to synthetic asset (in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthMintFees: string;
    /**
     * Int64(e8), the fees collected from swaps from synthetic asset to rune (in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthRedeemFees: string;
    /**
     * Int64(e8), toAssetFees + toRuneFees + synthMintFees + synthRedeemFees
     * @type {string}
     * @memberof SwapHistoryItem
     */
    totalFees: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from rune to asset. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toAssetAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from asset to rune. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    toRuneAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from rune to synthetic asset. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthMintAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from synthetic asset to rune. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    synthRedeemAverageSlip: string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the weighted average (by count) of toAssetAverageSlip, toRuneAverageSlip, synthMintAverageSlip, synthRedeemAverageSlip. Big swaps have the same weight as small swaps. 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    averageSlip: string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    runePriceUSD: string;
}
/**
 * 
 * @export
 * @interface SwapMetadata
 */
export interface SwapMetadata {
    /**
     * List of network fees associated to an action. One network fee is charged for each outbound transaction
     * @type {Array<Coin>}
     * @memberof SwapMetadata
     */
    networkFees: Array<Coin>;
    /**
     * Int64(e8), RUNE amount charged as swap liquidity fee
     * @type {string}
     * @memberof SwapMetadata
     */
    liquidityFee: string;
    /**
     * Int64 (Basis points, 0-10000, where 10000=100%), swap slip percentage
     * @type {string}
     * @memberof SwapMetadata
     */
    swapSlip: string;
    /**
     * Int64(e8), minimum output amount specified for the swap
     * @type {string}
     * @memberof SwapMetadata
     */
    swapTarget: string;
}
/**
 * 
 * @export
 * @interface THORNameDetails
 */
export interface THORNameDetails {
    /**
     * owner\'s THOR address
     * @type {string}
     * @memberof THORNameDetails
     */
    owner: string;
    /**
     * Int64, THORChain block height in which THORName expires
     * @type {string}
     * @memberof THORNameDetails
     */
    expire: string;
    /**
     * List details of all chains and their addresses for a given THORName
     * @type {Array<THORNameEntry>}
     * @memberof THORNameDetails
     */
    entries: Array<THORNameEntry>;
}
/**
 * 
 * @export
 * @interface THORNameEntry
 */
export interface THORNameEntry {
    /**
     * blockchain
     * @type {string}
     * @memberof THORNameEntry
     */
    chain: string;
    /**
     * address on blockchain
     * @type {string}
     * @memberof THORNameEntry
     */
    address: string;
}
/**
 * 
 * @export
 * @interface TVLHistory
 */
export interface TVLHistory {
    /**
     * 
     * @type {TVLHistoryItem}
     * @memberof TVLHistory
     */
    meta: TVLHistoryItem;
    /**
     * 
     * @type {Array<TVLHistoryItem>}
     * @memberof TVLHistory
     */
    intervals: Array<TVLHistoryItem>;
}
/**
 * 
 * @export
 * @interface TVLHistoryItem
 */
export interface TVLHistoryItem {
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof TVLHistoryItem
     */
    startTime: string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof TVLHistoryItem
     */
    endTime: string;
    /**
     * Int64(e8) in rune, the total pooled value (both assets and rune) in all of the pools at the end of the interval Note: this is twice the aggregate Rune depth of all pools. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    totalValuePooled: string;
    /**
     * Int64(e8), the total amount of bonds (both active and standby) at the end of the interval
     * @type {string}
     * @memberof TVLHistoryItem
     */
    totalValueBonded?: string;
    /**
     * Int64(e8), total value locked in the chain (in rune) This equals `totalPooledValue + totalBondedValue`, as it combines the liquidity pools and bonds of the nodes. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    totalValueLocked?: string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    runePriceUSD: string;
}
/**
 * Transaction data
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Transaction id hash. Some transactions (such as outbound transactions made in the native asset) may have a zero value.
     * @type {string}
     * @memberof Transaction
     */
    txID: string;
    /**
     * Sender address
     * @type {string}
     * @memberof Transaction
     */
    address: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Transaction
     */
    coins: Array<Coin>;
}
/**
 * 
 * @export
 * @interface WithdrawMetadata
 */
export interface WithdrawMetadata {
    /**
     * Int64, amount of liquidity units removed from the member as result of the withdrawal
     * @type {string}
     * @memberof WithdrawMetadata
     */
    liquidityUnits: string;
    /**
     * Decimal (-1.0 <=> 1.0), indicates how assymetrical the withdrawal was. 0 means totally symetrical
     * @type {string}
     * @memberof WithdrawMetadata
     */
    asymmetry: string;
    /**
     * Int64 (Basis points, 0-10000, where 10000=100%), percentage of total pool ownership withdrawn
     * @type {string}
     * @memberof WithdrawMetadata
     */
    basisPoints: string;
    /**
     * List of network fees associated to an action. One network fee is charged for each outbound transaction
     * @type {Array<Coin>}
     * @memberof WithdrawMetadata
     */
    networkFees: Array<Coin>;
    /**
     * Int64, additional Rune payed out because of impermanent loss protection
     * @type {string}
     * @memberof WithdrawMetadata
     */
    impermanentLossProtection: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (address?: string, txid?: string, asset?: string, type?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory: async (pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pool' is not null or undefined
            assertParamExists('getDepthHistory', 'pool', pool)
            const localVarPath = `/v2/history/depths/{pool}`
                .replace(`{${"pool"}}`, encodeURIComponent(String(pool)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory: async (interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory: async (pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/liquidity_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMemberDetail', 'address', address)
            const localVarPath = `/v2/member/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses: async (pool?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPool', 'asset', asset)
            const localVarPath = `/v2/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats: async (asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPoolStats', 'asset', asset)
            const localVarPath = `/v2/pool/{asset}/stats`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: async (status?: 'available' | 'staged' | 'suspended', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedNodes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory: async (pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/swaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getTHORNameDetail', 'name', name)
            const localVarPath = `/v2/thorname/lookup/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTHORNamesByAddress', 'address', address)
            const localVarPath = `/v2/thorname/rlookup/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory: async (interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/tvl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(address?: string, txid?: string, asset?: string, type?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(address, txid, asset, type, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthHistory(pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepthHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarningsHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarningsHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarningsHistory(interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDetail(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDetail(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersAdresses(pool?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembersAdresses(pool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Node>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolStats(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolStatsDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolStats(asset, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPools(status?: 'available' | 'staged' | 'suspended', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PoolDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxiedConstants(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Constants>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxiedConstants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxiedInboundAddresses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InboundAddressesItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxiedInboundAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxiedLastblock(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastblockItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxiedLastblock(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxiedNodes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProxiedNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxiedNodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxiedQueue(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxiedQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwapHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwapHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTHORNameDetail(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<THORNameDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTHORNameDetail(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTHORNamesByAddress(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTHORNamesByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTVLHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TVLHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTVLHistory(interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(address?: string, txid?: string, asset?: string, type?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getActions(address, txid, asset, type, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<DepthHistory> {
            return localVarFp.getDepthHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<EarningsHistory> {
            return localVarFp.getEarningsHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<Health> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<LiquidityHistory> {
            return localVarFp.getLiquidityHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address: string, options?: any): AxiosPromise<MemberDetails> {
            return localVarFp.getMemberDetail(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getMembersAdresses(pool, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options?: any): AxiosPromise<Network> {
            return localVarFp.getNetworkData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): AxiosPromise<Array<Node>> {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset: string, options?: any): AxiosPromise<PoolDetail> {
            return localVarFp.getPool(asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all', options?: any): AxiosPromise<PoolStatsDetail> {
            return localVarFp.getPoolStats(asset, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status?: 'available' | 'staged' | 'suspended', options?: any): AxiosPromise<Array<PoolDetail>> {
            return localVarFp.getPools(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants(options?: any): AxiosPromise<Constants> {
            return localVarFp.getProxiedConstants(options).then((request) => request(axios, basePath));
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses(options?: any): AxiosPromise<Array<InboundAddressesItem>> {
            return localVarFp.getProxiedInboundAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock(options?: any): AxiosPromise<Array<LastblockItem>> {
            return localVarFp.getProxiedLastblock(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedNodes(options?: any): AxiosPromise<Array<ProxiedNode>> {
            return localVarFp.getProxiedNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue(options?: any): AxiosPromise<Queue> {
            return localVarFp.getProxiedQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<StatsData> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<SwapHistory> {
            return localVarFp.getSwapHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail(name: string, options?: any): AxiosPromise<THORNameDetails> {
            return localVarFp.getTHORNameDetail(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress(address: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTHORNamesByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<TVLHistory> {
            return localVarFp.getTVLHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getActions operation in DefaultApi.
 * @export
 * @interface DefaultApiGetActionsRequest
 */
export interface DefaultApiGetActionsRequest {
    /**
     * Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
     * @type {string}
     * @memberof DefaultApiGetActions
     */
    readonly address?: string

    /**
     * ID of any in/out tx related to the action
     * @type {string}
     * @memberof DefaultApiGetActions
     */
    readonly txid?: string

    /**
     * Any asset that is part of the action (CHAIN.SYMBOL)
     * @type {string}
     * @memberof DefaultApiGetActions
     */
    readonly asset?: string

    /**
     * One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
     * @type {string}
     * @memberof DefaultApiGetActions
     */
    readonly type?: string

    /**
     * number of actions returned, default is 50
     * @type {number}
     * @memberof DefaultApiGetActions
     */
    readonly limit?: number

    /**
     * pagination offset, default is 0
     * @type {number}
     * @memberof DefaultApiGetActions
     */
    readonly offset?: number
}

/**
 * Request parameters for getDepthHistory operation in DefaultApi.
 * @export
 * @interface DefaultApiGetDepthHistoryRequest
 */
export interface DefaultApiGetDepthHistoryRequest {
    /**
     * Return stats for this single pool.
     * @type {string}
     * @memberof DefaultApiGetDepthHistory
     */
    readonly pool: string

    /**
     * Interval of calculations
     * @type {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetDepthHistory
     */
    readonly interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'

    /**
     * Number of intervals to return. Should be between [1..400].
     * @type {number}
     * @memberof DefaultApiGetDepthHistory
     */
    readonly count?: number

    /**
     * End time of the query as unix timestamp. If only count is given, defaults to now.
     * @type {number}
     * @memberof DefaultApiGetDepthHistory
     */
    readonly to?: number

    /**
     * Start time of the query as unix timestamp
     * @type {number}
     * @memberof DefaultApiGetDepthHistory
     */
    readonly from?: number
}

/**
 * Request parameters for getEarningsHistory operation in DefaultApi.
 * @export
 * @interface DefaultApiGetEarningsHistoryRequest
 */
export interface DefaultApiGetEarningsHistoryRequest {
    /**
     * Interval of calculations
     * @type {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetEarningsHistory
     */
    readonly interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'

    /**
     * Number of intervals to return. Should be between [1..400].
     * @type {number}
     * @memberof DefaultApiGetEarningsHistory
     */
    readonly count?: number

    /**
     * End time of the query as unix timestamp. If only count is given, defaults to now.
     * @type {number}
     * @memberof DefaultApiGetEarningsHistory
     */
    readonly to?: number

    /**
     * Start time of the query as unix timestamp
     * @type {number}
     * @memberof DefaultApiGetEarningsHistory
     */
    readonly from?: number
}

/**
 * Request parameters for getLiquidityHistory operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLiquidityHistoryRequest
 */
export interface DefaultApiGetLiquidityHistoryRequest {
    /**
     * Return stats for given pool. Returns sum of all pools if missing
     * @type {string}
     * @memberof DefaultApiGetLiquidityHistory
     */
    readonly pool?: string

    /**
     * Interval of calculations
     * @type {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetLiquidityHistory
     */
    readonly interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'

    /**
     * Number of intervals to return. Should be between [1..400]
     * @type {number}
     * @memberof DefaultApiGetLiquidityHistory
     */
    readonly count?: number

    /**
     * End time of the query as unix timestamp. If only count is given, defaults to now
     * @type {number}
     * @memberof DefaultApiGetLiquidityHistory
     */
    readonly to?: number

    /**
     * Start time of the query as unix timestamp
     * @type {number}
     * @memberof DefaultApiGetLiquidityHistory
     */
    readonly from?: number
}

/**
 * Request parameters for getMemberDetail operation in DefaultApi.
 * @export
 * @interface DefaultApiGetMemberDetailRequest
 */
export interface DefaultApiGetMemberDetailRequest {
    /**
     * Address to match liquidity providers. Either a rune or an asset address may be given.
     * @type {string}
     * @memberof DefaultApiGetMemberDetail
     */
    readonly address: string
}

/**
 * Request parameters for getMembersAdresses operation in DefaultApi.
 * @export
 * @interface DefaultApiGetMembersAdressesRequest
 */
export interface DefaultApiGetMembersAdressesRequest {
    /**
     * Return only members present in the pool.
     * @type {string}
     * @memberof DefaultApiGetMembersAdresses
     */
    readonly pool?: string
}

/**
 * Request parameters for getPool operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPoolRequest
 */
export interface DefaultApiGetPoolRequest {
    /**
     * pool name
     * @type {string}
     * @memberof DefaultApiGetPool
     */
    readonly asset: string
}

/**
 * Request parameters for getPoolStats operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPoolStatsRequest
 */
export interface DefaultApiGetPoolStatsRequest {
    /**
     * pool name
     * @type {string}
     * @memberof DefaultApiGetPoolStats
     */
    readonly asset: string

    /**
     * Restricts aggregation type fields to the last period only. Default is 30d. 
     * @type {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'}
     * @memberof DefaultApiGetPoolStats
     */
    readonly period?: '1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'
}

/**
 * Request parameters for getPools operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPoolsRequest
 */
export interface DefaultApiGetPoolsRequest {
    /**
     * Filter for only pools with this status
     * @type {'available' | 'staged' | 'suspended'}
     * @memberof DefaultApiGetPools
     */
    readonly status?: 'available' | 'staged' | 'suspended'
}

/**
 * Request parameters for getSwapHistory operation in DefaultApi.
 * @export
 * @interface DefaultApiGetSwapHistoryRequest
 */
export interface DefaultApiGetSwapHistoryRequest {
    /**
     * Return history given pool. Returns sum of all pools if missing.
     * @type {string}
     * @memberof DefaultApiGetSwapHistory
     */
    readonly pool?: string

    /**
     * Interval of calculations
     * @type {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetSwapHistory
     */
    readonly interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'

    /**
     * Number of intervals to return. Should be between [1..400].
     * @type {number}
     * @memberof DefaultApiGetSwapHistory
     */
    readonly count?: number

    /**
     * End time of the query as unix timestamp. If only count is given, defaults to now.
     * @type {number}
     * @memberof DefaultApiGetSwapHistory
     */
    readonly to?: number

    /**
     * Start time of the query as unix timestamp
     * @type {number}
     * @memberof DefaultApiGetSwapHistory
     */
    readonly from?: number
}

/**
 * Request parameters for getTHORNameDetail operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTHORNameDetailRequest
 */
export interface DefaultApiGetTHORNameDetailRequest {
    /**
     * a THORName
     * @type {string}
     * @memberof DefaultApiGetTHORNameDetail
     */
    readonly name: string
}

/**
 * Request parameters for getTHORNamesByAddress operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTHORNamesByAddressRequest
 */
export interface DefaultApiGetTHORNamesByAddressRequest {
    /**
     * Address to match THORNames against.
     * @type {string}
     * @memberof DefaultApiGetTHORNamesByAddress
     */
    readonly address: string
}

/**
 * Request parameters for getTVLHistory operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTVLHistoryRequest
 */
export interface DefaultApiGetTVLHistoryRequest {
    /**
     * Interval of calculations
     * @type {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'}
     * @memberof DefaultApiGetTVLHistory
     */
    readonly interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'

    /**
     * Number of intervals to return. Should be between [1..400].
     * @type {number}
     * @memberof DefaultApiGetTVLHistory
     */
    readonly count?: number

    /**
     * End time of the query as unix timestamp. If only count is given, defaults to now.
     * @type {number}
     * @memberof DefaultApiGetTVLHistory
     */
    readonly to?: number

    /**
     * Start time of the query as unix timestamp
     * @type {number}
     * @memberof DefaultApiGetTVLHistory
     */
    readonly from?: number
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
     * @summary Actions List
     * @param {DefaultApiGetActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActions(requestParameters: DefaultApiGetActionsRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getActions(requestParameters.address, requestParameters.txid, requestParameters.asset, requestParameters.type, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Depth and Price History
     * @param {DefaultApiGetDepthHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDepthHistory(requestParameters: DefaultApiGetDepthHistoryRequest, options?: any) {
        return DefaultApiFp(this.configuration).getDepthHistory(requestParameters.pool, requestParameters.interval, requestParameters.count, requestParameters.to, requestParameters.from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Earnings History
     * @param {DefaultApiGetEarningsHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEarningsHistory(requestParameters: DefaultApiGetEarningsHistoryRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getEarningsHistory(requestParameters.interval, requestParameters.count, requestParameters.to, requestParameters.from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing the health response of the API
     * @summary Health Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: any) {
        return DefaultApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Liquidity Changes History
     * @param {DefaultApiGetLiquidityHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLiquidityHistory(requestParameters: DefaultApiGetLiquidityHistoryRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getLiquidityHistory(requestParameters.pool, requestParameters.interval, requestParameters.count, requestParameters.to, requestParameters.from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of statistics for all the liquidity providers associated with a given member address.
     * @summary Member Details
     * @param {DefaultApiGetMemberDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMemberDetail(requestParameters: DefaultApiGetMemberDetailRequest, options?: any) {
        return DefaultApiFp(this.configuration).getMemberDetail(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
     * @summary Members List
     * @param {DefaultApiGetMembersAdressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMembersAdresses(requestParameters: DefaultApiGetMembersAdressesRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getMembersAdresses(requestParameters.pool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing Network data
     * @summary Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNetworkData(options?: any) {
        return DefaultApiFp(this.configuration).getNetworkData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Node public keys and adresses.
     * @summary Nodes List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNodes(options?: any) {
        return DefaultApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of the pool: depths, price, 24h volume, APY. 
     * @summary Details of a Pool
     * @param {DefaultApiGetPoolRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPool(requestParameters: DefaultApiGetPoolRequest, options?: any) {
        return DefaultApiFp(this.configuration).getPool(requestParameters.asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
     * @summary Pool Statistics
     * @param {DefaultApiGetPoolStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolStats(requestParameters: DefaultApiGetPoolStatsRequest, options?: any) {
        return DefaultApiFp(this.configuration).getPoolStats(requestParameters.asset, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing details for a set of pools
     * @summary Pools List
     * @param {DefaultApiGetPoolsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPools(requestParameters: DefaultApiGetPoolsRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getPools(requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Constant values used by THORChain , some of the values can be overrided by mimir
     * @summary Proxied THORChain Constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProxiedConstants(options?: any) {
        return DefaultApiFp(this.configuration).getProxiedConstants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
     * @summary Proxied THORChain Inbound Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProxiedInboundAddresses(options?: any) {
        return DefaultApiFp(this.configuration).getProxiedInboundAddresses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve lastest block infomation across all chains.
     * @summary Proxied THORChain Lastblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProxiedLastblock(options?: any) {
        return DefaultApiFp(this.configuration).getProxiedLastblock(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the proxied nodes endpoint from thornode
     * @summary Proxied THORChain Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProxiedNodes(options?: any) {
        return DefaultApiFp(this.configuration).getProxiedNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the proxied queue endpoint from thornode
     * @summary Proxied THORChain Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProxiedQueue(options?: any) {
        return DefaultApiFp(this.configuration).getProxiedQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing global stats for all pools and all transactions
     * @summary Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStats(options?: any) {
        return DefaultApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Swaps History
     * @param {DefaultApiGetSwapHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSwapHistory(requestParameters: DefaultApiGetSwapHistoryRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getSwapHistory(requestParameters.pool, requestParameters.interval, requestParameters.count, requestParameters.to, requestParameters.from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of chains and their addresses associated with the given THORName
     * @summary THORName Details
     * @param {DefaultApiGetTHORNameDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTHORNameDetail(requestParameters: DefaultApiGetTHORNameDetailRequest, options?: any) {
        return DefaultApiFp(this.configuration).getTHORNameDetail(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of THORNames associated with the given address
     * @summary Gives a list of THORNames by reverse lookup
     * @param {DefaultApiGetTHORNamesByAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTHORNamesByAddress(requestParameters: DefaultApiGetTHORNamesByAddressRequest, options?: any) {
        return DefaultApiFp(this.configuration).getTHORNamesByAddress(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Total Value Locked History
     * @param {DefaultApiGetTVLHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTVLHistory(requestParameters: DefaultApiGetTVLHistoryRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).getTVLHistory(requestParameters.interval, requestParameters.count, requestParameters.to, requestParameters.from, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpecificationApi - axios parameter creator
 * @export
 */
export const SpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecificationApi - functional programming interface
 * @export
 */
export const SpecificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwagger(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwagger(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpecificationApi - factory interface
 * @export
 */
export const SpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecificationApiFp(configuration)
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options?: any): AxiosPromise<void> {
            return localVarFp.getDocs(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options?: any): AxiosPromise<void> {
            return localVarFp.getSwagger(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
export class SpecificationApi extends BaseAPI {
    /**
     * Swagger/OpenAPI 3.0 specification generated documents.
     * @summary Documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getDocs(options?: any) {
        return SpecificationApiFp(this.configuration).getDocs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns human and machine readable swagger/openapi specification
     * @summary Swagger File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getSwagger(options?: any) {
        return SpecificationApiFp(this.configuration).getSwagger(options).then((request) => request(this.axios, this.basePath));
    }
}


